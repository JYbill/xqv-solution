<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>超大文件下载HTTP range方案</title>
</head>
<body>
  <button class="download">下载超大文件</button>

  <script src="https://cdn.jsdelivr.net/npm/streamsaver@2.0.6/StreamSaver.min.js"></script>
  <script>
    class OversizeFileDownloader {
      url;
      limitSize;
      processHandler; // 进度钩子

      // 下面数据结束后需要重置
      isDownload = false; // 是否正在下载
      fileTotalSize = 0; // 总二进制大小（字节）
      filename = ""; // 文件名
      bufferPos = 0; // 已下载字节大小
      constructor(url, processHandler, limitSize = 1024 * 1024 * 1024) {
        if (!url) {
          throw TypeError("url is must")
        }
        this.url = url;
        this.limitSize = limitSize; // 默认1G
        if (!processHandler) {
          this.processHandler = function() {
            console.log("progress", (this.bufferPos / this.fileTotalSize * 100).toFixed(2) + "%");
          }
        }
      }

      /**
       * 下载核心处理
       * @returns {Promise<void>}
       */
      async downloadCore() {
        if (this.isDownload) {
          console.warn("downloader is running, pls wait 'isDownload = false'");
          return;
        }
        this.isDownload = true;
        console.log("😄 start downloading");

        const res = await this.downloadFile();
        this.filename = res.filename;
        this.fileTotalSize = res.fileTotalSize;
        let {reader} = res;
        const fileStream = streamSaver.createWriteStream(this.filename, { size: this.fileTotalSize })
        const writer = fileStream.getWriter();

        // 分片循环下载
        while (this.bufferPos < this.fileTotalSize) {
          let done = false; // 本次HTTP range是否写入完毕

          // 循环读取二进制并写入writeable stream
          while (!done) {
            const bufferRes = await reader.read();
            const buffer = bufferRes.value;
            done = bufferRes.done;
            if (!done) {
              await writer.ready.then(async () => {
                await writer.write(buffer);
                this.bufferPos += buffer.length;
                this.processHandler.call(this);
              })
            }
          }

          // 获取下一个range范围的二进制流
          const retryRes = await this.downloadFile(this.bufferPos);
          reader = retryRes.reader;
        }
        writer.ready.then(() => {
          writer.close();
        })
        writer.closed.then(() => {
          console.log("✅ 下载完毕");
          this.resetState();
        })
      }

      resetState() {
        this.isDownload = false;
        this.fileTotalSize = 0;
        this.filename = "";
        this.bufferPos = 0;
      }

      /**
       * HTTP Range下载文件二进制
       * @param startPos
       * @returns {Promise<{res: Response, filename: string, size: number, reader: ReadableStreamDefaultReader<R>, fileTotalSize: number, contentLength: number}>}
       */
      async downloadFile(startPos = 0) {
        const endPos = this.limitSize + startPos;
        const res = await fetch(this.url, {
          method: "GET",
          headers: {
            'Range': `bytes=${startPos}-${endPos}`
          }
        })
        let contentDisposition = res.headers.get("Content-Disposition");
        contentDisposition = contentDisposition.split("filename=")[1];
        contentDisposition = contentDisposition.replaceAll(`"`, '');
        const size = Number(res.headers.get("Content-Length"));
        const fileTotalSize = Number(res.headers.get('File-Total-Size'));
        const contentLength = Number(res.headers.get('Content-Length'));
        return {
          res,
          reader: res.body.getReader(),
          filename: contentDisposition,
          size,
          fileTotalSize,
          contentLength
        };
      }
    }
  </script>
  <script>
    const btn = document.querySelector(".download");
    const downloader = new OversizeFileDownloader("/api/");
    btn.addEventListener("click", () => {
      downloader.downloadCore();
    })
  </script>
</body>
</html>
